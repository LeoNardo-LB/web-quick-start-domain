schema: spec-driven

context: |
  Tech stack: Java 25, Spring Boot 4.0.2, MyBatis Plus 3.5.16
  Architecture: DDD 4-layer (Domain → Application → Infrastructure → Adapter)
  
  详细规范: AGENTS.md
  测试规范: test/AGENTS.md

  ═══════════════════════════════════════════════════════════════════════════════
  TDD 整体流程（apply 阶段必须遵守）
  ═══════════════════════════════════════════════════════════════════════════════
  
  所有编码任务必须遵循 TDD：🔴 Red → 🟢 Green → 🔵 Refactor
  
  流程示意：
  ┌─────────────────────────────────────────────────────────────────────────┐
  │  X.Y.1 [测试]  🔴 RED   创建测试文件 → 测试失败（符合预期）            │
  │       ↓                                                                 │
  │  X.Y.2 [实现]  🟢 GREEN 编写最小实现 → 测试通过                        │
  │       ↓                                                                 │
  │  X.Y.3 [验证]  🔵 REFACTOR lsp_diagnostics → 零错误                    │
  │       ↓                                                                 │
  │  X.Y.4 [验证]  ✓        运行测试 → 通过                                │
  └─────────────────────────────────────────────────────────────────────────┘
  
  四阶段验证：
  ┌──────────────┬───────────────────────────────────┬─────────────┐
  │ 阶段         │ 动作                              │ 标准        │
  ├──────────────┼───────────────────────────────────┼─────────────┤
  │ 1. LSP检查   │ 每个文件完成后 lsp_diagnostics    │ 零错误      │
  │ 2. 单元测试  │ TODOLIST完成后运行单测            │ 100% 通过   │
  │ 3. 集成测试  │ 所有开发完成后运行集测            │ 100% 通过   │
  │ 4. 抽检      │ 抽检10%单测+10%集测               │ 100% 通过   │
  └──────────────┴───────────────────────────────────┴─────────────┘

rules:
  tasks:
    # ═══════════════════════════════════════════════════════════════════════════════
    # TODO 创建规则（NON-NEGOTIABLE）- 会在 apply 阶段注入到 prompt
    # ═══════════════════════════════════════════════════════════════════════════════

    - "**[强制-粒度]** TODO 必须严格按 tasks.md 的 X.Y.Z 三级粒度创建，禁止合并子任务"

    - |
      ❌ 错误示例（合并粒度）：
        7.1 修改 OrderConfigure.java 注册验证器 Bean  ← 合并了4个子任务
      
      ✅ 正确示例（严格映射）：
        7.1.1 [测试] 创建 OrderConfigureUTest.java
        7.1.2 [实现] 修改 OrderConfigure.java
        7.1.3 [验证] lsp_diagnostics → 零错误
        7.1.4 [验证] 运行测试 → 通过

    - "**[强制-分离]** `[测试]` 任务和 `[实现]` 任务必须分开创建 TODO"

    # ═══════════════════════════════════════════════════════════════════════════════
    # 执行顺序规则（NON-NEGOTIABLE）
    # ═══════════════════════════════════════════════════════════════════════════════

    - "**[强制-前置]** 执行 `[实现]` 任务前，必须确认对应的 `[测试]` 文件已存在"

    - |
      执行检查流程：
      1. 读取 tasks.md 找到当前任务的 X.Y 编号
      2. 检查是否存在 X.Y.1 **[测试]** 任务
      3. 如果存在，用 glob 检查对应测试文件
      4. 如果文件不存在 → 先执行 X.Y.1 创建测试
      5. 如果文件存在 → 继续执行当前任务

    - "**[强制-禁止]** 禁止以下反模式："
    - "  ❌ 跳过测试任务直接实现"
    - "  ❌ 先写实现，后补测试"
    - "  ❌ 标记 TODO 完成时，对应的 `[验证]` 未通过"

    # ═══════════════════════════════════════════════════════════════════════════════
    # 任务格式规范
    # ═══════════════════════════════════════════════════════════════════════════════

    - "**[格式]** tasks.md 任务格式："
    - "  - [ ] X.Y.1 **[测试]** 创建 XxxUTest.java - 验证 xxx 行为"
    - "  - [ ] X.Y.2 **[实现]** 创建 Xxx.java - 实现 xxx 功能"
    - "  - [ ] X.Y.3 **[验证]** 运行 lsp_diagnostics → 零错误"
    - "  - [ ] X.Y.4 **[验证]** 运行测试 → 通过"

    - "**[覆盖率]** 测试覆盖率要求："
    - "  - 单元测试：assert 覆盖所有分支（正常、边界、异常）"
    - "  - 集成测试：以顶层/次顶层方法为入口，覆盖重要场景"
    - "  - 目标：通过率 100%"

    - "**[命名]** 测试命名规范："
    - "  - 单元测试：XxxUTest.java（如 OrderAppServiceUTest）"
    - "  - 集成测试：XxxITest.java（如 OrderControllerITest）"

    # ═══════════════════════════════════════════════════════════════════════════════
    # 验证命令
    # ═══════════════════════════════════════════════════════════════════════════════

    - "**[命令]** 验证命令："
    - "  - LSP检查: lsp_diagnostics(filePath) → 零错误"
    - "  - 单元测试: mvn test -Dtest=XxxUTest -pl test"
    - "  - 集成测试: mvn test -Dtest=XxxITest -pl test"
    - "  - 启动验证: mvn test -Dtest=ApplicationStartupTests -pl test"
